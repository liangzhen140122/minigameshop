<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>俄罗斯方块 - Tetris</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Noto+Sans+SC:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: #ffffff;
      font-family: 'Noto Sans SC', sans-serif;
      color: #333;
      padding: 1rem;
    }

    .back-link {
      position: fixed;
      top: 1rem;
      left: 1rem;
      color: #666;
      text-decoration: none;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }
    .back-link:hover { color: #ff8f00; }

    .game-wrapper {
      display: flex;
      flex-wrap: wrap;
      gap: 1.5rem;
      justify-content: center;
      align-items: flex-start;
    }

    .game-container {
      background: #fff;
      border-radius: 20px;
      padding: 1.5rem;
      border: 1px solid #e0e0e0;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
    }

    h1 {
      font-size: 1.75rem;
      font-weight: 700;
      text-align: center;
      margin-bottom: 0.5rem;
      letter-spacing: 2px;
      background: linear-gradient(90deg, #ff8f00, #ffeb3b);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .subtitle {
      text-align: center;
      color: #666;
      font-size: 0.9rem;
      margin-bottom: 1rem;
    }

    .board-area {
      display: flex;
      gap: 1rem;
      justify-content: center;
      flex-wrap: wrap;
    }

    #gameBoard {
      display: grid;
      grid-template-columns: repeat(10, 24px);
      grid-template-rows: repeat(20, 24px);
      gap: 1px;
      background: #1a1a2e;
      padding: 4px;
      border-radius: 8px;
      box-shadow: inset 0 0 0 2px #333;
    }

    .cell {
      width: 24px;
      height: 24px;
      border-radius: 3px;
      background: #16213e;
    }

    .cell.filled { box-shadow: inset 0 0 0 1px rgba(255,255,255,0.2); }

    .cell.I { background: #00f5ff; }
    .cell.O { background: #ffeb3b; }
    .cell.T { background: #bf5af2; }
    .cell.S { background: #30d158; }
    .cell.Z { background: #ff453a; }
    .cell.J { background: #0a84ff; }
    .cell.L { background: #ff9f0a; }

    .side-panel {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      min-width: 120px;
    }

    .info-box {
      background: #f8f8f8;
      border-radius: 12px;
      padding: 1rem;
      text-align: center;
      border: 1px solid #eee;
    }

    .info-box h3 {
      font-size: 0.75rem;
      color: #999;
      margin-bottom: 0.25rem;
      text-transform: uppercase;
    }

    .info-box .value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.25rem;
      font-weight: 600;
      color: #333;
    }

    #nextPiece {
      display: grid;
      grid-template-columns: repeat(4, 20px);
      grid-template-rows: repeat(4, 20px);
      gap: 1px;
      margin: 0 auto;
      width: fit-content;
      background: #16213e;
      padding: 4px;
      border-radius: 6px;
    }

    #nextPiece .cell {
      width: 20px;
      height: 20px;
    }

    .controls {
      margin-top: 1rem;
      padding: 1rem;
      background: #fff8e1;
      border-radius: 12px;
      border: 1px solid #ffecb3;
      font-size: 0.85rem;
      color: #555;
    }

    .controls h3 {
      font-size: 0.9rem;
      color: #f57f17;
      margin-bottom: 0.5rem;
    }

    .controls kbd {
      background: #fff;
      padding: 0.15rem 0.4rem;
      border-radius: 4px;
      border: 1px solid #ddd;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8rem;
    }

    .controls p { margin: 0.25rem 0; }

    button {
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      font-family: 'Noto Sans SC', sans-serif;
      font-weight: 600;
      background: linear-gradient(135deg, #ff8f00, #ffeb3b);
      color: #333;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      margin-top: 0.5rem;
      width: 100%;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(255, 143, 0, 0.4);
    }

    .game-over-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      border-radius: 20px;
      color: white;
    }

    .game-over-overlay h2 {
      font-size: 1.5rem;
      margin-bottom: 0.5rem;
    }

    .game-over-overlay p {
      color: #ccc;
      margin-bottom: 1rem;
    }

    .relative { position: relative; }
  </style>
</head>
<body>
  <a href="index.html" class="back-link">← 返回游戏列表</a>

  <div class="game-wrapper">
    <div class="game-container relative">
      <h1>俄罗斯方块</h1>
      <p class="subtitle">Tetris · 消除方块得分</p>

      <div class="board-area">
        <div id="gameBoard"></div>
        <div class="side-panel">
          <div class="info-box">
            <h3>分数</h3>
            <div class="value" id="score">0</div>
          </div>
          <div class="info-box">
            <h3>等级</h3>
            <div class="value" id="level">1</div>
          </div>
          <div class="info-box">
            <h3>消除行</h3>
            <div class="value" id="lines">0</div>
          </div>
          <div class="info-box">
            <h3>下一个</h3>
            <div id="nextPiece"></div>
          </div>
          <button id="startBtn">开始游戏</button>
        </div>
      </div>

      <div class="controls">
        <h3>操作说明</h3>
        <p><kbd>←</kbd><kbd>→</kbd> 左右移动 · <kbd>↓</kbd> 加速下落</p>
        <p><kbd>↑</kbd> 旋转 · <kbd>空格</kbd> 瞬间落底</p>
      </div>

      <div id="gameOverOverlay" class="game-over-overlay" style="display: none;">
        <h2>游戏结束</h2>
        <p id="finalScore">最终得分: 0</p>
        <button id="restartBtn">再来一局</button>
      </div>
    </div>
  </div>

  <script>
    const COLS = 10, ROWS = 20;
    const PIECES = {
      I: [[1,1,1,1]],
      O: [[1,1],[1,1]],
      T: [[0,1,0],[1,1,1]],
      S: [[0,1,1],[1,1,0]],
      Z: [[1,1,0],[0,1,1]],
      J: [[1,0,0],[1,1,1]],
      L: [[0,0,1],[1,1,1]]
    };

    const COLORS = { I: 'I', O: 'O', T: 'T', S: 'S', Z: 'Z', J: 'J', L: 'L' };

    let board = [];
    let currentPiece = null;
    let nextPiece = null;
    let score = 0, level = 1, lines = 0;
    let gameLoop = null;
    let isPlaying = false;
    let dropInterval = 1000;

    const gameBoard = document.getElementById('gameBoard');
    const nextPieceEl = document.getElementById('nextPiece');
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const linesEl = document.getElementById('lines');
    const startBtn = document.getElementById('startBtn');
    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const finalScoreEl = document.getElementById('finalScore');
    const restartBtn = document.getElementById('restartBtn');

    function initBoard() {
      gameBoard.innerHTML = '';
      board = Array(ROWS).fill().map(() => Array(COLS).fill(null));
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.r = r;
          cell.dataset.c = c;
          gameBoard.appendChild(cell);
        }
      }
    }

    function randomPiece() {
      const types = Object.keys(PIECES);
      const type = types[Math.floor(Math.random() * types.length)];
      return { type, shape: PIECES[type].map(row => [...row]), x: 3, y: 0 };
    }

    function rotate(shape) {
      return shape[0].map((_, i) => shape.map(row => row[i]).reverse());
    }

    function collide(piece, ox = 0, oy = 0) {
      for (let r = 0; r < piece.shape.length; r++) {
        for (let c = 0; c < piece.shape[r].length; c++) {
          if (piece.shape[r][c]) {
            const ny = piece.y + r + oy, nx = piece.x + c + ox;
            if (nx < 0 || nx >= COLS || ny >= ROWS) return true;
            if (ny >= 0 && board[ny][nx]) return true;
          }
        }
      }
      return false;
    }

    function merge() {
      if (!currentPiece) return;
      for (let r = 0; r < currentPiece.shape.length; r++) {
        for (let c = 0; c < currentPiece.shape[r].length; c++) {
          if (currentPiece.shape[r][c]) {
            const ny = currentPiece.y + r, nx = currentPiece.x + c;
            if (ny >= 0) board[ny][nx] = currentPiece.type;
          }
        }
      }
    }

    function clearLines() {
      let cleared = 0;
      for (let r = ROWS - 1; r >= 0; r--) {
        if (board[r].every(cell => cell)) {
          board.splice(r, 1);
          board.unshift(Array(COLS).fill(null));
          cleared++;
          r++;
        }
      }
      if (cleared > 0) {
        const points = [0, 100, 300, 500, 800][cleared] || 800;
        score += points * level;
        lines += cleared;
        level = Math.floor(lines / 10) + 1;
        dropInterval = Math.max(100, 1000 - (level - 1) * 100);
      }
    }

    function spawn() {
      currentPiece = nextPiece || randomPiece();
      nextPiece = randomPiece();
      if (collide(currentPiece)) {
        gameOver();
        return;
      }
      renderNext();
    }

    function renderNext() {
      nextPieceEl.innerHTML = '';
      const size = 4;
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          if (nextPiece && r < nextPiece.shape.length && c < nextPiece.shape[r].length && nextPiece.shape[r][c]) {
            cell.classList.add('filled', nextPiece.type);
          }
          nextPieceEl.appendChild(cell);
        }
      }
    }

    function drop() {
      if (!isPlaying || !currentPiece) return;
      if (collide(currentPiece, 0, 1)) {
        merge();
        clearLines();
        spawn();
      } else {
        currentPiece.y++;
      }
      render();
      updateUI();
    }

    function render() {
      const cells = gameBoard.querySelectorAll('.cell');
      const display = board.map(row => [...row]);
      if (currentPiece) {
        for (let r = 0; r < currentPiece.shape.length; r++) {
          for (let c = 0; c < currentPiece.shape[r].length; c++) {
            if (currentPiece.shape[r][c]) {
              const ny = currentPiece.y + r, nx = currentPiece.x + c;
              if (ny >= 0 && ny < ROWS && nx >= 0 && nx < COLS) {
                display[ny][nx] = currentPiece.type;
              }
            }
          }
        }
      }
      cells.forEach((cell, i) => {
        const r = Math.floor(i / COLS), c = i % COLS;
        cell.className = 'cell';
        if (display[r][c]) cell.classList.add('filled', display[r][c]);
      });
    }

    function updateUI() {
      scoreEl.textContent = score;
      levelEl.textContent = level;
      linesEl.textContent = lines;
    }

    function move(dx) {
      if (!currentPiece || !isPlaying) return;
      if (!collide(currentPiece, dx, 0)) {
        currentPiece.x += dx;
        render();
      }
    }

    function hardDrop() {
      if (!currentPiece || !isPlaying) return;
      while (!collide(currentPiece, 0, 1)) {
        currentPiece.y++;
        score += 2;
      }
      merge();
      clearLines();
      spawn();
      render();
      updateUI();
    }

    function rotatePiece() {
      if (!currentPiece || !isPlaying) return;
      const rotated = { ...currentPiece, shape: rotate(currentPiece.shape) };
      if (!collide(rotated)) {
        currentPiece.shape = rotated.shape;
        render();
      }
    }

    function gameOver() {
      isPlaying = false;
      if (gameLoop) clearTimeout(gameLoop);
      finalScoreEl.textContent = `最终得分: ${score}`;
      gameOverOverlay.style.display = 'flex';
    }

    function startGame() {
      initBoard();
      board = Array(ROWS).fill().map(() => Array(COLS).fill(null));
      score = 0;
      level = 1;
      lines = 0;
      dropInterval = 1000;
      isPlaying = true;
      gameOverOverlay.style.display = 'none';
      nextPiece = randomPiece();
      spawn();
      render();
      updateUI();
      startBtn.textContent = '游戏中...';
      startBtn.disabled = true;
      function tick() {
        if (!isPlaying) return;
        drop();
        gameLoop = setTimeout(tick, dropInterval);
      }
      gameLoop = setTimeout(tick, dropInterval);
    }

    function resetGame() {
      isPlaying = false;
      if (gameLoop) clearTimeout(gameLoop);
      startBtn.textContent = '开始游戏';
      startBtn.disabled = false;
    }

    document.addEventListener('keydown', (e) => {
      if (!isPlaying) return;
      e.preventDefault();
      switch (e.key) {
        case 'ArrowLeft': move(-1); break;
        case 'ArrowRight': move(1); break;
        case 'ArrowDown': drop(); score += 1; updateUI(); break;
        case 'ArrowUp': rotatePiece(); break;
        case ' ': hardDrop(); break;
      }
    });

    startBtn.addEventListener('click', () => {
      if (isPlaying) return;
      startGame();
    });

    restartBtn.addEventListener('click', () => {
      gameOverOverlay.style.display = 'none';
      resetGame();
      startGame();
    });

    initBoard();
    renderNext();
    updateUI();
  </script>
</body>
</html>
